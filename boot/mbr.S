;主引导程序，起始编译地址为0x7c00
;-----------------------------------------------------------------------------------------
SECTION MBR vstart=0x7c00 
    mov ax,cs
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00
    ;ds = es = ss = 0 栈指针指向MBR开始位置

;利用0x06号功能清屏
;-----------------------------------------------------------------------------------------
;ah = 0x06 功能号
;al = 0x00 上卷的行数 0位全部
;bh: 上卷行属性
;cx: (CL,CH) 窗口左上角(x,y)
;dx: (DL,DH) 窗口右下角(x,y)

    mov ax,0x600 
    mov bx,0x700
    mov cx,0
    mov dx,0x184f           ;0x18=24 0xfe=79,VGA文本模式下一行只能容纳80个字符，共25行
                            ;下标从0开始
    
    int 0x10 

;获取光标的位置
;---------------------------------------------------------------------------------------
;输入 ah=3号子功能是获取鼠标的位置，
;输入 bh=存储的是待获取光标的页号
;输出 ch=光标所在行，cl=光标结束行 dh=光标所在行号，dl=光标所在列号
    mov ah,3                
    mov bh,0                

    int 0x10                

;打印字符串
;--------------------------------------------------------------------------------------
;调用13号子功能打印字符串
;cx=为串的长度
;ah=子功能号13 

;al=写字符的方式 01=显示字符串，光标跟随移动
;al=O 显示字符串，并且光标返回起始位置。
;al=l 显示字符串，并且光标跟随到新位置。
;al=2 显示字符串及其属性，并且光标返回起始位置
;al=3 显示字符串及其属性，光标跟随到新位置。

;bh=显示的页号，此处0页， 
;bl=字符属性，黑底绿字bl=02h
    mov ax,message
    mov bp,ax               ;es bp 为串首地址，es通cs一致，上面初始化的
    
    mov cx,5                
    mov ax,0x1301           
    mov bx,0x2;
    
    int 0x10 

;程序收尾
;--------------------------------------------------------------------------------------
;预留两个字节 其余空余的全部用0填满 为使检测当前扇区最后两字节为0x55 0xaa 检测是否为有效扇区
;字符串声明 db == define byte dw == define word ascii一个字符占一个字节
    jmp $ ;无限循环 一直跳转到当前命令位置
    
    message db "1 MBR" 
    
    ;510 = 512字节-2预留字节  再减去（当前位置偏移量-段开始位置偏移量）求出来的是剩余空间
    times 510 - ($ - $$) db 0 
    db 0x55,0xaa
